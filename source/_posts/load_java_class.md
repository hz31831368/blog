---
title: Java类加载过程
date: 2017/8/19
tags: Java虚拟机
---

#### 类的生命周期
![图片](http://on3qybwfn.bkt.clouddn.com/timg.jpg)  

其中，加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，而解析则不一定，它有可能在初始化阶段之后在开始，这是为了支持Java语言的运行时绑定(也称动态绑定和运行时绑定)。
#### 虚拟机规范严格规定了有且只有5种情况必须立即对类进行初始化(而加载、验证、准备自然需要在此之前开始)：
- 遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果没有初始化，则必须先触发其初始化。生成这4条指令最常见的Java代码场景是：使用new关键字实例化对象的时候，读取或设置一个类的静态字段(被final修饰、已在编译器把结果放入常量池的静态字段除外)的时候，以及调用一个类的的静态方法的时候
- 使用java.lang.reflect包的方法对类进行反射调用的时候。
- 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
- 当虚拟机启动时，用户需要指定一个要执行的主类(包含main方法那个类)，虚拟机会先初始化这个类。
- 当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化则需要先触发其初始化。

除以上5点之外，所有引用类的方式都不会触发初始化，这称为被动引用。以下3个例子为被动引用

```
//通过子类引用父类的静态字段，不会导致子类初始化
System.out.println(SubClass.value);

//通过数组定义来引用类，不会触发此类的初始化
SuperClass[] sca = new SuperClass[10];

//常量在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义常量的类，因此不会和促发定义常量的类的初始化。
System.out.println(ConstClass.HELLOWORLD);
```
<!-- more --> 

#### 类加载的过程
##### 加载
加载是类加载过程的一个阶段，在加载阶段，虚拟机需要完成以下3件事情
- 通过一个类的全限定名来获取定义此类的二进制字节流。
- 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
- 将内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。

##### 验证
验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。大致会完成下面4个阶段
- 文件格式验证
- 元数据验证
- 字节码验证
- 符号引用验证

##### 准备
准备阶段是正式为类变量分配内存并设置变量初始值的阶段，但是这时候进行内存分配的仅包括类变量(被static修饰的变量)，而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。另外这里所说的初始值通常情况下是数据类型的零值，假设一个类变量的定义为：

```
public static int value = 123;
```
那变量value在准备阶段过后的初始值为0而不是123，因为这时候尚未开始执行任何Java方法，而把value赋值为123的putstatic指令是程序被编译后，存放于类构造器<clinit>()方法之中，所以把value赋值为123的动作将在初始化阶段才会执行。

数据类型 | 零值 | 数据类型 | 零值
---|--- | ---|---
int | 0 | boolean | false
long | 0L | float | 0.0f
short | (short)0 | double | 0.0d
char | '\u0000' | reference | null
byte | (byte)0

上面提到通常情况下初始值是零值，那相对会有一些特殊情况

```
public static final int value = 123;
```
这种情况下，编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为123。

##### 解析
解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。

##### 初始化
类初始化阶段是类加载过程的最后一步，前面的类加载过程，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的Java程序代码(或者说是字节码)。  
  
在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则根据程序员通过程序制定的主观计划区初始化类变量和其他资源，或者可以从另外一个角度来表达：初始化阶段是执行类构造器<clinit>()方法的过程。
- <clint>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句(static{}块)中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。

```
public class Test {
    static {
        i = 0; //给变量赋值可以正常通过编译
        System.out.prin(i)  //这局编译器会提示 "非法向前引用"
    }
    
    static int i = 1;
}
```
- 虚拟机会保证一个类的<clint>()方法在多线程环境中被正确地加锁、同步、如果多个线程同时去初始化一个类，那么只有一个线程去执行这个类的<clinit>()方法，其他线程都需要阻塞等待，直到活动线程的<clinit>()方法完毕。

